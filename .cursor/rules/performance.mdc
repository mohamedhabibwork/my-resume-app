# Performance Best Practices

## Vue Performance Optimizations

### 1. Lazy Load Routes

```typescript
// router/index.ts
const routes = [
  {
    path: '/',
    name: 'home',
    component: () => import('@/views/HomeView.vue')
  },
  {
    path: '/dashboard',
    name: 'dashboard',
    component: () => import('@/views/DashboardView.vue'),
    meta: { requiresAuth: true }
  },
  {
    path: '/resume/:id',
    name: 'resume-builder',
    component: () => import('@/views/ResumeBuilderView.vue')
  }
]
```

### 2. Use `v-once` for Static Content

```vue
<!-- Content that never changes -->
<footer v-once class="bg-gray-100 p-4">
  <p>© 2024 My Resume App. All rights reserved.</p>
</footer>

<!-- Static icons or images -->
<img v-once src="/logo.svg" alt="Logo" />
```

### 3. Use `v-memo` for Expensive List Renders

```vue
<!-- Only re-render when dependencies change -->
<div
  v-for="item in items"
  :key="item.id"
  v-memo="[item.id, item.updatedAt, isSelected(item.id)]"
>
  <ExpensiveComponent :data="item" :selected="isSelected(item.id)" />
</div>
```

### 4. Use `shallowRef` for Large Objects

```typescript
import { shallowRef } from 'vue'

// ✅ For large objects that don't need deep reactivity
const largeDataset = shallowRef<DataItem[]>([])

// Replace entire array to trigger reactivity
largeDataset.value = [...newData]

// ❌ This won't trigger reactivity with shallowRef
// largeDataset.value[0].name = 'new name'
```

### 5. Use `markRaw` for Non-reactive Data

```typescript
import { markRaw, reactive } from 'vue'

// Third-party libraries or static data
const chart = markRaw(new ChartLibrary())
const staticConfig = markRaw({
  apiKey: 'xxx',
  options: { ... }
})

const state = reactive({
  chart, // Won't be made reactive
  config: staticConfig
})
```

### 6. Computed Caching

```typescript
// ✅ CORRECT - Computed values are cached
const filteredItems = computed(() => {
  return items.value.filter(item => item.active)
})

// ❌ WRONG - Method is called every render
function getFilteredItems() {
  return items.value.filter(item => item.active)
}
```

### 7. Debounce Expensive Operations

```typescript
import { useDebounceFn } from '@/composables'

// Debounce search
const searchQuery = ref('')
const debouncedSearch = useDebounceFn(async (query: string) => {
  await performSearch(query)
}, 300)

watch(searchQuery, (query) => {
  debouncedSearch(query)
})

// Debounce resize handlers
const handleResize = useDebounceFn(() => {
  recalculateLayout()
}, 150)

window.addEventListener('resize', handleResize)
```

### 8. Virtual Scrolling for Long Lists

```vue
<!-- For lists with 1000+ items, use virtual scrolling -->
<script setup lang="ts">
import { useVirtualList } from '@vueuse/core'

const items = ref(Array.from({ length: 10000 }, (_, i) => ({ id: i, name: `Item ${i}` })))

const { list, containerProps, wrapperProps } = useVirtualList(items, {
  itemHeight: 50,
})
</script>

<template>
  <div v-bind="containerProps" class="h-96 overflow-auto">
    <div v-bind="wrapperProps">
      <div v-for="item in list" :key="item.index" class="h-[50px]">
        {{ item.data.name }}
      </div>
    </div>
  </div>
</template>
```

## Component Optimization

### Async Components

```typescript
import { defineAsyncComponent } from 'vue'

// Lazy load heavy components
const HeavyChart = defineAsyncComponent(() =>
  import('@/components/HeavyChart.vue')
)

// With loading and error states
const HeavyChart = defineAsyncComponent({
  loader: () => import('@/components/HeavyChart.vue'),
  loadingComponent: LoadingSpinner,
  errorComponent: ErrorDisplay,
  delay: 200,
  timeout: 10000
})
```

### Keep-Alive for Cached Components

```vue
<!-- Cache component state when switching -->
<router-view v-slot="{ Component }">
  <keep-alive :include="['DashboardView', 'ResumeBuilderView']">
    <component :is="Component" />
  </keep-alive>
</router-view>

<!-- Or with max cached instances -->
<keep-alive :max="5">
  <component :is="currentComponent" />
</keep-alive>
```

## Network Optimization

### 1. Implement Caching

```typescript
const cache = new Map<string, { data: unknown; timestamp: number }>()
const CACHE_TTL = 5 * 60 * 1000 // 5 minutes

async function fetchWithCache<T>(url: string): Promise<T> {
  const cached = cache.get(url)

  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return cached.data as T
  }

  const data = await fetch(url).then(r => r.json())
  cache.set(url, { data, timestamp: Date.now() })
  return data
}
```

### 2. Pagination for Large Datasets

```typescript
const page = ref(1)
const pageSize = ref(20)
const hasMore = ref(true)

async function loadMore() {
  if (!hasMore.value || isLoading.value) return

  isLoading.value = true
  const response = await fetch(`/api/items?page=${page.value}&size=${pageSize.value}`)
  const data = await response.json()

  items.value.push(...data.items)
  hasMore.value = data.hasMore
  page.value++
  isLoading.value = false
}
```

### 3. Optimistic Updates

```typescript
async function updateItem(id: string, data: Partial<Item>) {
  // Optimistically update UI
  const index = items.value.findIndex(i => i.id === id)
  const original = items.value[index]
  items.value[index] = { ...original, ...data }

  try {
    await api.updateItem(id, data)
  } catch (error) {
    // Revert on failure
    items.value[index] = original
    showError('Failed to update')
  }
}
```

## Image Optimization

### 1. Lazy Loading Images

```vue
<img
  loading="lazy"
  :src="imageSrc"
  alt="Description"
  class="w-full h-auto"
/>
```

### 2. Responsive Images

```vue
<img
  :srcset="`
    ${imageSmall} 480w,
    ${imageMedium} 768w,
    ${imageLarge} 1200w
  `"
  sizes="(max-width: 480px) 100vw, (max-width: 768px) 50vw, 33vw"
  :src="imageMedium"
  alt="Description"
/>
```

### 3. WebP Format

```vue
<picture>
  <source :srcset="imageWebp" type="image/webp" />
  <source :srcset="imagePng" type="image/png" />
  <img :src="imagePng" alt="Description" />
</picture>
```

## Build Optimization

### Tree Shaking

```typescript
// ✅ CORRECT - Named imports enable tree shaking
import { ref, computed, watch } from 'vue'
import { formatDate, capitalize } from '@/utils'

// ❌ WRONG - Imports entire module
import * as Vue from 'vue'
import * as utils from '@/utils'
```

### Bundle Analysis

```bash
# Analyze bundle size
bun run build -- --report

# Or use rollup-plugin-visualizer in vite.config.ts
```

### Code Splitting

```typescript
// vite.config.ts
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          'vendor': ['vue', 'vue-router', 'pinia'],
          'firebase': ['firebase/app', 'firebase/auth', 'firebase/firestore'],
          'ui': ['@vueuse/core']
        }
      }
    }
  }
})
```

## Performance Monitoring

### Web Vitals

```typescript
// Track Core Web Vitals
import { onCLS, onFID, onLCP, onFCP, onTTFB } from 'web-vitals'

function sendToAnalytics(metric: Metric) {
  console.log(metric)
  // Send to analytics service
}

onCLS(sendToAnalytics)
onFID(sendToAnalytics)
onLCP(sendToAnalytics)
onFCP(sendToAnalytics)
onTTFB(sendToAnalytics)
```

### Vue DevTools Profiling

Use Vue DevTools Performance tab to:
- Identify slow renders
- Find unnecessary re-renders
- Analyze component hierarchy
- Debug reactivity issues

## Checklist

- [ ] Routes are lazy loaded
- [ ] Large lists use virtual scrolling
- [ ] Images are lazy loaded and optimized
- [ ] API responses are cached where appropriate
- [ ] Heavy computations use `computed` or are debounced
- [ ] Static content uses `v-once`
- [ ] No unnecessary watchers
- [ ] Bundle size is analyzed and optimized
- [ ] Core Web Vitals are monitored
